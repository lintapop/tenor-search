import { Game } from './Game';
import { Query, UserQueryDef, QueryEvents } from './Query';
import { EntityImpostorFor } from './QueryIterator';
interface TrackingQueryEvents extends QueryEvents {
    change(): void;
}
export declare interface TrackingQuery {
    on<U extends keyof TrackingQueryEvents>(ev: U, cb: TrackingQueryEvents[U]): this;
    off<U extends keyof TrackingQueryEvents>(ev: U, cb: TrackingQueryEvents[U]): this;
    emit<U extends keyof TrackingQueryEvents>(ev: U, ...args: Parameters<TrackingQueryEvents[U]>): boolean;
}
export declare class TrackingQuery<Def extends UserQueryDef = UserQueryDef> extends Query<Def> {
    private trackedEntities;
    private addedThisFrame;
    private removedThisFrame;
    private changesThisFrame;
    private addedIterable;
    constructor(game: Game);
    get entities(): readonly number[];
    get addedIds(): readonly number[];
    get added(): {
        [Symbol.iterator]: () => AddedIterator<Def>;
    };
    get removedIds(): readonly number[];
    initialize(def: Def): void;
    /**
     * Add an async function which is called with an Entity as it
     * is added to the query, and returns a cleanup callback to call when
     * the Entity is removed.
     */
    process: (processor: (ent: EntityImpostorFor<Def>) => Promise<() => void>) => void;
    private addToList;
    private removeFromList;
    private resetStepTracking;
    private processAddRemove;
}
declare class AddedIterator<Def extends UserQueryDef> implements Iterator<EntityImpostorFor<Def>> {
    private game;
    private query;
    private index;
    private result;
    constructor(game: Game, query: TrackingQuery);
    next(): IteratorResult<EntityImpostorFor<Def>, any>;
}
export {};
