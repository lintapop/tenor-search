var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { EventEmitter } from 'events';
import { ArchetypeManager } from './ArchetypeManager';
import { TrackingQuery } from './TrackingQuery';
import { ComponentA, ComponentB, ComponentC, ComponentD, } from './__tests__/componentFixtures';
var withA = 100;
var withAB = 101;
var withB = 102;
var withC = 103;
var withD = 104;
var withAD = 105;
var MockGame = /** @class */ (function (_super) {
    __extends(MockGame, _super);
    function MockGame(archetypeManager) {
        var _this = _super.call(this) || this;
        _this.archetypeManager = archetypeManager;
        return _this;
    }
    return MockGame;
}(EventEmitter));
describe('TrackingQuery', function () {
    var game;
    function addEntity(eid, components) {
        game.archetypeManager.createEntity(eid);
        components.forEach(function (comp) {
            game.archetypeManager.addComponent(eid, comp);
        });
    }
    beforeEach(function () {
        var archetypeManager = new ArchetypeManager({
            componentManager: {
                componentTypes: {
                    length: 10,
                },
            },
        });
        game = new MockGame(archetypeManager);
        addEntity(withA, [new ComponentA()]);
        addEntity(withB, [new ComponentB()]);
        addEntity(withAB, [new ComponentA(), new ComponentB()]);
        addEntity(withC, [new ComponentC()]);
        addEntity(withD, [new ComponentD()]);
        addEntity(withAD, [new ComponentA(), new ComponentD()]);
    });
    it('maintains a list of matching entities', function () {
        var onChange = jest.fn();
        var query = new TrackingQuery(game);
        query.on('change', onChange);
        query.initialize([ComponentA]);
        expect(query.entities).toEqual([withA, withAB, withAD]);
        expect(query.addedIds).toEqual([withA, withAB, withAD]);
        expect(onChange).toHaveBeenCalledTimes(1);
        // reset frame tracking
        game.emit('preApplyOperations');
        onChange.mockClear();
        expect(query.entities).toEqual([withA, withAB, withAD]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // simple add case
        game.archetypeManager.addComponent(withC, new ComponentA());
        game.emit('stepComplete');
        expect(query.entities).toEqual([withA, withAB, withAD, withC]);
        expect(query.addedIds).toEqual([withC]);
        expect(query.removedIds).toEqual([]);
        expect(onChange).toHaveBeenCalledTimes(1);
        game.emit('preApplyOperations');
        onChange.mockClear();
        expect(query.entities).toEqual([withA, withAB, withAD, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // simple remove case
        game.archetypeManager.removeComponent(withAD, ComponentA.id);
        game.emit('stepComplete');
        expect(query.entities).toEqual([withA, withAB, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([withAD]);
        expect(onChange).toHaveBeenCalledTimes(1);
        game.emit('preApplyOperations');
        onChange.mockClear();
        expect(query.entities).toEqual([withA, withAB, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // internal move archetype case
        game.archetypeManager.addComponent(withA, new ComponentC());
        game.emit('stepComplete');
        expect(query.entities).toEqual([withAB, withC, withA]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        expect(onChange).not.toHaveBeenCalled();
    });
});
//# sourceMappingURL=TrackingQuery.test.js.map